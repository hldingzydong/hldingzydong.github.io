---
layout: post
title:  CMU15-445 Spring2018 Lab4
date:   2020-02-29
author: hding
catalog: true
tags:
   - database
---
# [Lab4](https://15445.courses.cs.cmu.edu/fall2018/project4/)

## Task #1 - Log Manager
实现一个LogManager,和BPM一样,对于整个DBMS它是唯一的,为整个系统服务。在Task1中主要实现两个功能,一个是LogManager可以后台起一个线程,在合适的时候将buffer中的log写到disk中;为txn提供可以将log保存到buffer中的接口。

#### 数据结构
###### Log Record
对于一条log记录,需要记录:该log的id(Log Sequence Number,LSN),对应的txn的id,这条log的size,它的上一条log的id和它的type,如下所示:
```
 For EACH log record, HEADER is like (5 fields in common, 20 bytes in total)
-------------------------------------------------------------
 | size | LSN | transID | prevLSN | LogType |
-------------------------------------------------------------
 For insert type log record
-------------------------------------------------------------
 | HEADER | tuple_rid | tuple_size | tuple_data(char[] array) |
-------------------------------------------------------------
 For delete type(including markdelete, rollbackdelete, applydelete)
-------------------------------------------------------------
 | HEADER | tuple_rid | tuple_size | tuple_data(char[] array) |
-------------------------------------------------------------
 For update type log record
-----------------------------------------------------------------------------------
 | HEADER | tuple_rid | tuple_size | old_tuple_data | tuple_size | new_tuple_data |
-----------------------------------------------------------------------------------
 For new page type log record
-------------------------------------------------------------
 | HEADER | prev_page_id |
-------------------------------------------------------------
```
log的type主要有以下几类:
```c++
enum class LogRecordType {
  INVALID = 0,
  INSERT,         // txn插入一个tuple
  MARKDELETE,     // txn将某个tuple标记成delete,但最终是否delete取决于该txn最终commit还是abort
  APPLYDELETE,    // txn最终commit
  ROLLBACKDELETE, // txn最终abort
  UPDATE,         // txn更新某个tuple,此时log要记录old_value和new_value
  BEGIN,          // txn的状态:Begin、Commit和Abort
  COMMIT,
  ABORT,
  NEWPAGE,        // when create a new page in heap table
};
```
由此我们可以得到对一个LogRecord的class的数据成员:
```c++
  // the length of log record(for serialization, in bytes)
  int32_t size_ = 0;
  // common fields
  lsn_t lsn_ = INVALID_LSN;
  txn_id_t txn_id_ = INVALID_TXN_ID;
  lsn_t prev_lsn_ = INVALID_LSN;
  LogRecordType log_record_type_ = LogRecordType::INVALID;
  // case1: for delete operation, delete_tuple_ for UNDO operation
  RID delete_rid_;
  Tuple delete_tuple_;
  // case2: for insert operation
  RID insert_rid_;
  Tuple insert_tuple_;
  // case3: for update operation
  RID update_rid_;
  Tuple old_tuple_;
  Tuple new_tuple_;
  // case4: for new page operation
  page_id_t prev_page_id_ = INVALID_PAGE_ID;
  const static int HEADER_SIZE = 20;
```

###### Log Manager
首先,LogManager需要两个buffer,一个用来将其中的log写到disk中,称其为flush_buffer,另一个用来存储run-time时产生的log,称其为log_buffer,这样可以保证在持久化至disk的同时保证最新的log可以写到LogManager中,同时应当记录每个buffer的size。还需要存有**flushedLSN**,即在disk中的最新的log的LSN。
```c++
  // 每创造一条logRecord时,其LSN由该变量生成
  std::atomic<lsn_t> next_lsn_;
  // 上述的flushedLSN
  std::atomic<lsn_t> persistent_lsn_;
  // 用于存储run-time时生成的log的buffer
  char *log_buffer_;
  int log_buffer_size_{0};
  // 用于写入disk时用的buffer
  char *flush_buffer_;
  int flush_buffer_size_{0};
  // latch to protect shared member variables
  std::mutex latch_;
  // flush flush_buffer_到disk中的线程
  std::thread *flush_thread_;
  // for notifying flush thread
  std::condition_variable cv_;
  // disk manager
  DiskManager *disk_manager_;
  // flag
  std::atomic<bool> flush_thread_on;

  std::condition_variable flushed;

  std::mutex log_mtx_;
```


#### Impletation
在Spec中要求实现 **[group commit](https://wiki.postgresql.org/wiki/Group_commit)** 该feature,但由于未找到与其相关的代码,故省略.
###### flush线程
什么时候需要flush到disk中去呢?当flush_buffer满的时候需要;LogManager需要定时去flush log到disk中;当BPM需要evict一个脏页的时候,需要flush,因为evict脏页时需要将该脏页写回disk中,此时必须保证该脏页的log已经被持久化至disk中.  
定时如何实现?使用condition variable的wait_for API
```c++
cv_.wait_for(lock, LOG_TIMEOUT);
```
而判断是否已满,在每次向log_buffer中写log时判断(包含在被txn使用的接口(AppendLogRecord)中):
```c++
if(size + log_buffer_size_ > LOG_BUFFER_SIZE)
```
完整的thread实现如下:
```c++
void LogManager::bgFsync() {
  while (flush_thread_on) {
    std::unique_lock<std::mutex> lock(latch_);
    while (log_buffer_size_ == 0) {
      // 定时
      auto ret = cv_.wait_for(lock, LOG_TIMEOUT);
      if (ret == std::cv_status::no_timeout || flush_thread_on == false) {
        break;
      }
    }
    //swap 两块buffer
    std::swap(flush_buffer_, log_buffer_);
    flush_buffer_size_ = log_buffer_size_;
    log_buffer_size_ = 0;
    

    // 将flush_buffer_中的log写入磁盘
    disk_manager_->WriteLog(flush_buffer_, flush_buffer_size_);
    std::unique_lock<std::mutex> lock(latch_);
    //更新 flushedLSN
    auto lsn = lastLsn(flush_buffer_, flush_buffer_size_);
    if (lsn != INVALID_LSN) {
      SetPersistentLSN(lsn);
    }

    flush_buffer_size_ = 0;
    // 通知flush操作已完成
    flushed.notify_all();
  }
}
```
```c++
// 返回buff里面的最后一条log的lsn
int LogManager::lastLsn(char *buff, int size) {
  lsn_t cur = INVALID_LSN;
  char *ptr = buff;
  while (ptr < buff + size) {
    auto rec = reinterpret_cast<LogRecord *>(ptr);
    cur = rec->GetLSN();
    auto len = rec->GetSize();
    ptr = ptr + len;
  }
  return cur;
}
```


###### 为txn暴露的API
```c++
lsn_t LogManager::AppendLogRecord(LogRecord &log_record) {
  auto size = log_record.GetSize();
  std::unique_lock<std::mutex> guard(log_mtx_);
  std::unique_lock<std::mutex> guard2(latch_);
  // 为该record赋予LSN
  log_record.lsn_ = next_lsn_++;
  if (size + log_buffer_size_ > LOG_BUFFER_SIZE) {
    // 叫醒flush线程
    GetBgTaskToWork();
    guard2.unlock();
    // 等待flush线程结束
    WaitUntilBgTaskFinish();
    assert(log_buffer_size_ == 0);
    guard2.lock();
  }

  // 将log_record添加至log_buffer_中
  int pos = log_buffer_size_;
  memcpy(log_buffer_ + pos, &log_record, LogRecord::HEADER_SIZE);
  pos += LogRecord::HEADER_SIZE;

  // 针对不同type的logRecord,需要将不同的data添加至log_buffer_中
  if (log_record.log_record_type_ == LogRecordType::INSERT) {
    memcpy(log_buffer_ + pos, &log_record.insert_rid_, sizeof(RID));
    pos += sizeof(RID);
    // tuple提供了序列化的函数
    log_record.insert_tuple_.SerializeTo(log_buffer_ + pos);
  } else if (log_record.log_record_type_ == LogRecordType::APPLYDELETE
      || log_record.log_record_type_ == LogRecordType::MARKDELETE
      || log_record.log_record_type_ == LogRecordType::ROLLBACKDELETE) {
    memcpy(log_buffer_ + pos, &log_record.delete_rid_, sizeof(RID));
    pos += sizeof(RID);
    log_record.delete_tuple_.SerializeTo(log_buffer_ + pos);
  } else if (log_record.log_record_type_ == LogRecordType::UPDATE) {
    memcpy(log_buffer_ + pos, &log_record.update_rid_, sizeof(RID));
    pos += sizeof(RID);
    log_record.old_tuple_.SerializeTo(log_buffer_ + pos);
    pos += log_record.old_tuple_.GetLength() + sizeof(int32_t);
    log_record.new_tuple_.SerializeTo(log_buffer_ + pos);
  } else if (log_record.log_record_type_ == LogRecordType::NEWPAGE) {
    memcpy(log_buffer_ + pos, &log_record.prev_page_id_, sizeof(log_record.prev_page_id_));
  }

  // 更新log_buffer_的size
  log_buffer_size_ += size;
  // 返回添加进去的logRecord的LSN
  return log_record.lsn_;
}
```

txn在Commit时,生成一个**COMMIT**类型的logRecord,调用上述function将其添加至log_buffer_中:
```c++
if (ENABLE_LOGGING) {
    // 生成COMMIT类型的logRecord
    LogRecord log(txn->GetTransactionId(), txn->GetPrevLSN(), LogRecordType::COMMIT);
    txn->SetPrevLSN(log_manager_->AppendLogRecord(log));
    // 因为该txn在commit,必须等到log已经写入到disk中才可以返回，通知user该txn commit了
    while(txn->GetPrevLSN() > log_manager_->GetPersistentLSN())
    {
      std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
  }
```














